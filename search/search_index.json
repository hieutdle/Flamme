{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"DSA/LeetCode/cpp-note/","title":"Cpp Leetcode note","text":""},{"location":"DSA/LeetCode/cpp-note/#217","title":"217","text":""},{"location":"DSA/LeetCode/cpp-note/#find","title":"find()","text":"<pre><code>s.find(nums[i]) != s.end()\n</code></pre> <p><code>s.find(value)</code> searches the <code>std::unordered_set</code> for the element value. It returns an iterator:</p> <ul> <li>If the element exists in the set, the iterator points to that element.</li> <li>If the element does not exist, the iterator is equal to <code>s.end()</code>.</li> <li><code>s.end()</code> is a special iterator that points to the past-the-end position of the set.</li> </ul> <pre><code>!s.insert(num).second\n</code></pre>"},{"location":"DSA/LeetCode/cpp-note/#insert","title":"insert()","text":"<ul> <li><code>s.insert(num)</code> tries to insert the element num into the set <code>s</code>.</li> <li>It returns a <code>std::pair</code>:</li> <li>First element (<code>iterator</code>): An iterator pointing to the position of the element in the set.</li> <li>Second element (<code>bool</code>): A boolean that indicates whether the insertion was successful:<ul> <li><code>true</code>: The element was successfully inserted because it didn\u2019t already exist in the set.</li> <li><code>false</code>: The insertion failed because the element already existed in the set.</li> </ul> </li> </ul>"},{"location":"DSA/LeetCode/cpp-note/#49","title":"49","text":""},{"location":"DSA/LeetCode/cpp-note/#as-reference-and-address-of-operator","title":"&amp; as Reference and Address-of Operator","text":"<p><code>&amp;</code> as Reference:</p> <p>When used in a declaration, &amp; signifies that the variable is a reference to another object. A reference is essentially an alias for an existing object.</p> <pre><code>int a = 10;\nint &amp;ref = a; // ref is a reference to a\nref = 20; // This changes a to 20\n</code></pre> <p><code>&amp;</code> as Address-of Operator:</p> <p>When used in an expression, <code>&amp;</code> fetches the memory address of a variable.</p> <pre><code>int a = 10;\nint *ptr = &amp;a; // ptr stores the address of a\n</code></pre> <p>In for <code>(auto &amp;n : m)</code>, the <code>&amp;</code> means that <code>n</code> is a reference to each element of the container <code>m</code> during iteration. This avoids making a copy of the element. If you use for <code>(auto n : m)</code> instead, <code>n</code> becomes a copy of each element. This can be less efficient for large or complex objects.</p>"},{"location":"DSA/LeetCode/cpp-note/#emplace_back-vs-push_back","title":"emplace_back vs. push_back","text":"<ul> <li><code>push_back</code>: Adds a new element at the end of the container, after its current last element. The content of val is copied (or moved) to the new element.</li> <li><code>emplace_back</code>: Inserts a new element at the end of the container, right after its current last element. This new element is constructed in place using args as the arguments for its constructor.</li> </ul> <p>To be more clear, what will happen if we call push_back?</p> <ul> <li>A constructor will be called to create a temporary object.</li> <li>A copy of the temporary object will be constructed in the memory for the container. Note that the move constructor will be called if exist because the temporary object is an rvalue, otherwise the copy constructor should be called.</li> <li>The destructor will be called to destroy the temporary object after copy.</li> </ul> <pre><code>class MyClass {\npublic:\n    MyClass(int x, int y) : x_(x), y_(y) {\n        std::cout &lt;&lt; \"Create class\" &lt;&lt; std::endl;\n    }\n\n    ~MyClass() {\n        std::cout &lt;&lt; \"Destroy class\" &lt;&lt; std::endl;\n    }\n\n    // Copy Constructor\n    MyClass(const MyClass&amp; my_class) {\n        std::cout &lt;&lt; \"Copy Constructor Called\" &lt;&lt; std::endl;\n        x_ = my_class.x_;\n    }\n\n    // Move Constructor\n    MyClass (MyClass&amp;&amp; my_class) noexcept {\n        std::cout &lt;&lt; \"Move Constructor Called\" &lt;&lt; std::endl;\n        x_ = std::move(my_class.x_);\n    }\n\nprivate:\n    int x_ = 0;\n    int y_ = 0;\n\n};\n\n\nint main() {\n    std::vector&lt;MyClass&gt; vector;\n    // Reserve space to avoid reallocation\n    vector.reserve(2);\n\n    std::cout &lt;&lt; \"\\n--- push_back ---\" &lt;&lt; std::endl;\n    vector.push_back(MyClass(1, 2));\n\n    std::cout &lt;&lt; \"\\n--- emplace_back ---\" &lt;&lt; std::endl;\n    vector.emplace_back(1, 2);\n\n    std::cout &lt;&lt; \"\\n--- Finish ---\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>Output:</p> <p>--- push_back --- Create Class Move Constructor Called Destroy Class</p> <p>--- emplace_back --- Create Class</p> <p>--- Finish --- Destroy Class Destroy Class</p> <p><code>push_back</code> method calls the move constructor to make a copy and the destructor to destroy the temporary object. But <code>emplace_back</code> construct the object directly.</p> <p>With the simple benchmark here, we notice that <code>emplace_back</code> is 7.62% faster than <code>push_back</code> when we insert 1,000,000 object (MyClass) into an vector.</p> <pre><code>Insert 1,000,000 objects.\n\n--- push_back ---\npush_back takes 0.00665344 seconds.\n\n--- emplace_back ---\nemplace_back takes 0.00614631 seconds.\n</code></pre> <p>Why not use emplace_back all the time? We elaborate some of benefits of emplace_back method above, you might want to ask - Can we just get rid of the push_back method of containers?</p> <ol> <li>Ambiguity of Constructor Calls</li> </ol> <pre><code>std::vector&lt;std::vector&lt;int&gt;&gt; vec1, vec2;\n// vec1.push_back(1000000); // compile error\nvec2.emplace_back(1000000);\n</code></pre> <ul> <li> <p><code>push_back(1000000)</code> fails because push_back requires a fully constructed object. A single integer <code>(1000000)</code> is not a <code>std::vector&lt;int&gt;</code>.</p> </li> <li> <p><code>emplace_back(1000000)</code> succeeds because emplace_back directly calls a constructor of <code>std::vector&lt;int&gt;</code> that takes an <code>integer</code>. This constructs a <code>std::vector&lt;int&gt;</code> of size <code>1,000,000</code>.</p> </li> </ul> <p>In some cases the transformation would be valid, but the code wouldn\u2019t be exception safe. In this case the calls of <code>push_back</code> won\u2019t be replaced.</p> <pre><code>std::vector&lt;std::unique_ptr&lt;int&gt;&gt; v;\nv.push_back(std::unique_ptr&lt;int&gt;(new int(0)))\n</code></pre> <p>This is because replacing it with <code>emplace_back</code> could cause a leak of this pointer if emplace_back would throw exception before emplacement (e.g. not enough memory to add a new element).</p> <p>Backwards compatibility with pre-C++11 compilers (no emplace_back).</p> <p><code>push_back</code> always allows the use of uniform initialization, which I'm very fond of. For instance:</p> <pre><code>struct aggregate {\n    int foo;\n    int bar;\n};\n\nstd::vector&lt;aggregate&gt; v;\nv.push_back({ 42, 121 });\n</code></pre> <p>On the other hand, <code>v.emplace_back({ 42, 121 });</code> will not work.</p>"},{"location":"DSA/LeetCode/python-note/","title":"Python Leetcode note","text":""},{"location":"DSA/LeetCode/python-note/#49","title":"49","text":""},{"location":"DSA/LeetCode/python-note/#anagrams-a-standard-dictionary-and-dict-collectionsdefaultdictlist","title":"anagrams = {} (a standard dictionary) and dict = collections.defaultdict(list)","text":"<pre><code>dict = {}\n\ndefaultdict = collections.defaultdict(list)\n</code></pre> <ul> <li>Standard Dictionary raises <code>KeyError</code> if key is missing</li> <li>Default Dictionary creates a default value automatically (e.g., <code>[]</code> for <code>list</code>).</li> </ul> <pre><code>anagrams = defaultdict(list)\n        for str in strs:\n            # sort the word\n            sorted_word = \"\".join(sorted(str))\n            # Don't need to check if the sorted word is in the dictionary\n            anagrams[sorted_word].append(str)\n        return list(anagrams.values())\n\n        # anagrams = {}\n        # for str in strs:\n        #     # sort the word\n        #     sorted_word = \"\".join(sorted(str))\n        #     # if the sorted word is not in the dictionary, add it\n        #     if sorted_word not in anagrams:\n        #         anagrams[sorted_word] = [str]\n        #     else:\n        #         anagrams[sorted_word].append(word)\n        # return list(anagrams.values())\n</code></pre>"},{"location":"Fundamental%20Programming/CS106L/initialization-and-references/","title":"Lecture 3: Initialization and References","text":"<p>CS 106L: Standard C++ Programming (Autumn 2024):</p> <ul> <li>Course Website: Stanford</li> <li>Recordings: Youtube</li> </ul>"},{"location":"Fundamental%20Programming/CS106L/initialization-and-references/#initialization","title":"Initialization","text":"<p>What?: \u201cProvides initial values at the time of construction\u201d - cppreference.com</p>"},{"location":"Fundamental%20Programming/CS106L/initialization-and-references/#1-direct-initialization","title":"1. Direct initialization","text":"<pre><code>#include &lt;iostream&gt;\nint main() {\n    int numOne = 12.0;\n    int numTwo(12.0);\n    std::cout &lt;&lt; \"numOne is: \" &lt;&lt; numOne &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"numTwo is: \" &lt;&lt; numTwo &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>Notice\u203c: is 12.0 an int? NO C++ Doesn\u2019t Care.</p> <pre><code>Number One is: 12\nNumber Two is: 12\n</code></pre> <p>Problems:</p> <pre><code>#include &lt;iostream&gt;\nint main() {\n    // Direct initialization with a floating-point value\n    int criticalSystemValue(42.5);\n\n    // Critical system operations...\n    // ...\n    std::cout &lt;&lt; \"Critical system value: \" &lt;&lt; criticalSystemValue &lt;&lt; std::endl; return 0;\n}\n\nCritical system value: 42\n</code></pre> <p>C++ doesn\u2019t care in this case, it doesn\u2019t type check with direct initialization. So C++ said \u201cMeh, I\u2019ll store 42.5 as an int,\u201d and we possibly now have an error. This is commonly called a narrowing conversion</p>"},{"location":"Fundamental%20Programming/CS106L/initialization-and-references/#2-uniform-initialization-c-11","title":"2. Uniform initialization (C++ 11)","text":"<pre><code>#include &lt;iostream&gt;\nint main() {\n    // Notice the brackets\n    int numOne{12.0};\n    // should be 12 instead of 12.0\n    // int numOne{12};\n    float numTwo{12.0};\n    std::cout &lt;&lt; \"numOne is: \" &lt;&lt; numOne &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"numTwo is: \" &lt;&lt; numTwo &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>With uniform initialization C++ does care about types!</p> <pre><code>type `double` cannot be narrowed to `int`\n</code></pre> <p>Uniform initialization is awesome because:</p> <ol> <li>It\u2019s safe! It doesn\u2019t allow for narrowing conversions\u2014which can lead to unexpected behaviour (or critical system failures :o)</li> <li>It\u2019s ubiquitous it works for all types like vectors, maps, and custom    classes, among other things!</li> </ol> <pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nint main() {\n // Uniform initialization of a map\n    std::map&lt;std::string, int&gt; ages{\n            {\"Alice\", 25},\n            {\"Bob\" , 30},\n            {\"Charlie\", 35}\n        };\n\n    // Accessing map elements\n    std::cout &lt;&lt; \"Alice's age: \" &lt;&lt; ages[\"Alice\"] &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Bob's age: \" &lt;&lt; ages.at(\"Bob\") &lt;&lt; std::endl;\n\n   // Uniform initialization of a vector\n    std::vector&lt;int&gt; numbers{1, 2, 3, 4, 5};\n    // Accessing vector elements\n    for (int num : numbers) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"Fundamental%20Programming/CS106L/initialization-and-references/#3-structured-binding-c-17","title":"3. Structured Binding (C++ 17)","text":"<ul> <li>A useful way to initialize some variables from data structures with fixed sizes at compile time</li> <li>Ability to access multiple values returned by a function</li> <li>Can use on objects where the size is known at compile-time</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;tuple&gt;\n#include &lt;string&gt;\n\nstd::tuple&lt;std::string, std::string, std::string&gt; getClassInfo() {\n    std::string className = \"CS106L\";\n    std::string buildingName = \"Turing Auditorium\";\n    std::string language = \"C++\";\n    return {className, buildingName, language};\n}\n\nint main() {\n    auto classInfo = getClassInfo();\n    std::string className = std::get&lt;0&gt;(classInfo);\n    std::string buildingName = std::get&lt;1&gt;(classInfo);\n    std::string language = std::get&lt;2&gt;(classInfo);\n    std::cout &lt;&lt; \"Come to \" &lt;&lt; buildingName &lt;&lt; \" and join us for \" &lt;&lt; className\n    &lt;&lt; \" to learn \" &lt;&lt; language &lt;&lt; \"!\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"Fundamental%20Programming/CS106L/initialization-and-references/#references","title":"References","text":"<p>What?: \u201cDeclares a name variable as a reference\u201d tldr: a reference is an alias to an already-existing thing - cppreference.com.</p> <p>Use an ampersand (&amp;)</p> <pre><code>int num = 5;\nint&amp; ref = num;\nref = 10; // Assigning a new value through the reference\nstd::cout &lt;&lt; num &lt;&lt; std::endl; // Output: 10\n</code></pre> <p><code>num</code> is a variable of type <code>int</code>, that is assigned to have the value 5. <code>ref</code> is a variable of type <code>int&amp;</code>, that is an alias to <code>num</code>. So when we assign 10 to <code>ref</code>, we also change the value of <code>num</code>, since <code>ref</code> is an alias for <code>num</code>.</p> <p>A reference refers to the same memory as its associated variable!. Passing in a variable by reference into a function just means \u201cHey take in the actual piece of memory, don\u2019t make a copy!\u201d Passing in a variable by value into a function just means \u201cHey make a copy, don\u2019t take in the actual variable!\u201d</p>"},{"location":"Fundamental%20Programming/CS106L/initialization-and-references/#a-classic-reference-copy-bug","title":"A classic reference-copy bug","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;math.h&gt;\n#include &lt;vector&gt;\n\nvoid shift(std::vector&lt;std::pair&lt;int, int&gt;&gt; &amp;nums) {\n    for (auto [num1, num2] : nums) {\n        num1++;\n        num2++;\n    }\n}\n</code></pre> <p>We\u2019re not modifying <code>nums</code> in this function! We ar modifying the std::pair\u2019s inside of nums.</p>"},{"location":"Fundamental%20Programming/CS106L/initialization-and-references/#a-classic-reference-copy-bug-fixed","title":"A classic reference-copy bug: fixed!","text":"<pre><code>void shift(std::vector&lt;std::pair&lt;int, int&gt;&gt; &amp;nums) {\n    for (auto&amp; [num1, num2] : nums) {\n        num1++;\n        num2++;\n    }\n}\n</code></pre>"},{"location":"Fundamental%20Programming/CS106L/initialization-and-references/#l-values-and-r-values","title":"l-values and r-values","text":"<p>An l-value can be to the left or the right of an equal sign!</p> <pre><code>int y = x\n\n\u2705 AND \u2705\n\nx = 344\n</code></pre> <p>An r-value can be ONLY to the right of an equal sign!</p> <p><code>21</code> can be an r-value for instance because you can have something like:</p> <pre><code>int y = 21\n\n\u274c BUT NOT \u274c\n\n21 = x\n</code></pre>"},{"location":"Fundamental%20Programming/CS106L/initialization-and-references/#l-value-and-r-value-pain","title":"l-value and r-value PAIN","text":"<p>l-value and r-value PAIN</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n\nint squareN(int&amp; num) {\n    return std::pow(num, 2);\n}\n\nint main()\n{\n    int lValue = 2;\n    auto four = squareN(lValue);\n    auto fourAgain = squareN(2);\n    std::cout &lt;&lt; four &lt;&lt; std::endl;\n    return 0;\n}\n\nerror: candidate function not viable: expects an lvalue for 1st argument\nint squareN(int&amp; num){\n    ^\n</code></pre> <p><code>num</code> is an l-value!</p> <ul> <li>r-values are temporary. Notice that <code>num</code> is being passed in by reference!</li> <li>We cannot pass in an r-value by reference because they\u2019re temporary!</li> </ul>"},{"location":"Fundamental%20Programming/CS106L/initialization-and-references/#const","title":"const","text":"<p>What?: A qualifier for objects that declares they cannot be modified - cppreference.com.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main()\n{\n    std::vector&lt;int&gt; vec{ 1, 2, 3 };  /// a normal vector\n    const std::vector&lt;int&gt; const_vec{ 1, 2, 3 };  /// a const vector\n    std::vector&lt;int&gt;&amp; ref_vec{ vec };  /// a reference to 'vec'\n    const std::vector&lt;int&gt;&amp; const_ref{ vec };  /// a const reference\n\n    vec.push_back(3); /// this is ok!\n    const_vec.push_back(3); /// no, this is const!\n    ref_vec.push_back(3); /// this is ok, just a reference!\n    const_ref.push_back(3); /// this is const, compiler error!\n    return 0;\n}\n</code></pre> <p>You can\u2019t declare a non-const reference to a const variable</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main()\n{\n    /// a const vector\n    const std::vector&lt;int&gt; const_vec{ 1, 2, 3 };\n    std::vector&lt;int&gt;&amp; bad_ref{ const_vec };  /// BAD\n    const std::vector&lt;int&gt;&amp; bad_ref{ const_vec }; /// Good!\n\n    return 0;\n}\n</code></pre>"},{"location":"Fundamental%20Programming/CS106L/initialization-and-references/#compiling-c-programs","title":"Compiling C++ programs","text":"<ul> <li>A few popular compilers include clang and g++</li> <li>Here is how to compile a program using g++</li> </ul> <pre><code>g++ -std=c++11 main.cpp -o main\n</code></pre> <ul> <li><code>g++</code>: This is the compiler command</li> <li><code>-std=c++11</code> This specifies the c++ version you want to compile in</li> <li><code>main.cpp</code>: This is the source file</li> <li><code>-o</code>: This means that you\u2019re going to give a specific name to your executable</li> <li><code>main</code>: In this case it\u2019s main</li> </ul> <pre><code>g++ -std=c++11 main.cpp\n</code></pre> <p>This is also valid, your executable will be something like <code>a.out</code></p>"},{"location":"Fundamental%20Programming/CS106L/streams/","title":"Lecture 4: Streams","text":"<p>CS 106L: Standard C++ Programming (Autumn 2024):</p> <ul> <li>Course Website: Stanford</li> <li>Recordings: Youtube</li> </ul>"},{"location":"Fundamental%20Programming/CS106L/streams/#what-are-streams","title":"What are streams??!!","text":"<p>A general input/output(IO) abstraction for C+</p> <p>Abstractions provide a consistent interface, and in the case of streams the interface is for reading and writing data!</p>"},{"location":"Fundamental%20Programming/CS106L/types-and-structs/","title":"Lecture 2: Types and Structs","text":"<p>CS 106L: Standard C++ Programming (Autumn 2024):</p> <ul> <li>Course Website: Stanford</li> <li>Recordings: Youtube</li> </ul>"},{"location":"Fundamental%20Programming/CS106L/types-and-structs/#types","title":"Types","text":"<p>A type refers to the \u201ccategory\u201d of a variable</p> <p>C++ comes with built-in types:</p> <ul> <li><code>int 106</code></li> <li><code>double 71.4</code></li> <li><code>string \u201cWelcome to CS106L!\u201d</code></li> <li><code>bool true false</code></li> <li><code>size_t 12 // Non-negative</code></li> </ul>"},{"location":"Fundamental%20Programming/CS106L/types-and-structs/#static-typing","title":"Static Typing","text":"<ul> <li>Every variable must declare a type</li> <li>Once declared, the type cannot change</li> </ul>"},{"location":"Fundamental%20Programming/CS106L/types-and-structs/#why-static-typing","title":"Why static typing?","text":"<ul> <li>More efficient</li> <li>Easier to understand and reason about</li> <li>Better error checking</li> </ul> <pre><code>def add_3(x):\n    return x + 3\n\nadd_3(\"CS106L\") # Oops, that's a string. Runtime error!\n</code></pre> <pre><code>int add_3(int x) {\n    return x + 3;\n}\n\nadd_3(\"CS106L\"); // Can't pass a string when int expected. Compile time error!\n</code></pre>"},{"location":"Fundamental%20Programming/CS106L/types-and-structs/#function-overloading","title":"Function Overloading","text":"<p>Defining two functions with the same name but different signatures</p> <pre><code>double func(int x) { // (1)\n    return (double) x + 3; // typecast: int \u2192 double\n}\n\ndouble func(double x) { // (2)\n    return x * 3;\n}\n\nfunc(2); // uses version (1), returns (5.0)\nfunc(2.0); // uses version (2), returns (6.0)\n</code></pre>"},{"location":"Fundamental%20Programming/CS106L/types-and-structs/#structs","title":"Structs","text":"<p>Structs bundle data together</p> <pre><code>struct StanfordID {\n    string name; // These are called fields\n    string sunet; // Each has a name and type\n    int idNumber;\n};\n\nStanfordID id; // Initialize struct\nid.name = \"Jacob Roberts-Baca\"; // Access field with \u2018.\u2019\nid.sunet = \"jtrb\";\nid.idNumber = 6504417;\n</code></pre> <p>Returning multiple values</p> <pre><code>StanfordID issueNewID() {\n    StanfordID id;\n    id.name = \"Jacob Roberts-Baca\";\n    id.sunet = \"jtrb\";\n    id.idNumber = 6504417;\n    return id;\n}\n</code></pre> <p>List Initialization</p> <pre><code>// Order depends on field order in struct. \u2018=\u2018 is optional\nStanfordID jrb = { \"Jacob Roberts-Baca\", \"jtrb\", 6504417 };\nStanfordID fi { \u201dFabio Ibanez\", \u201dfibanez\", 6504418 };\n</code></pre> <p>Using list initialization</p> <pre><code>StanfordID issueNewID() {\n    StanfordID id = { \"Jacob Roberts-Baca\", \"jtrb\", 6504417 };\n    return id;\n}\n\nStanfordID issueNewID() {\n    return { \"Jacob Roberts-Baca\", \"jtrb\", 6504417 };\n}\n</code></pre> <p>A struct bundles named variables into a new type</p>"},{"location":"Fundamental%20Programming/CS106L/types-and-structs/#stdpair","title":"std::pair","text":"<pre><code>struct Order {\n    std::string item;\n    int quantity;\n};\n\nOrder dozen = { \"Eggs\", 12 };\n\n\nstd::pair&lt;std::string, int&gt; dozen { \"Eggs\", 12 };\nstd::string item = dozen.first; // \"Eggs\"\nint quantity = dozen.second; // 12\n</code></pre> <p><code>std::pair</code> is a template</p> <pre><code>template &lt;typename T1, typename T2&gt;\nstruct pair {\n    T1 first;\n    T2 second;\n};\nstd::pair&lt;std::string, int&gt;\n\nstruct pair {\n    std::string first;\n    int second;\n};\n</code></pre>"},{"location":"Fundamental%20Programming/CS106L/types-and-structs/#std-the-c-standard-library","title":"std \u2015 The C++ Standard Library","text":"<p>See the official standard at cppreference.com!</p> <p>To use <code>std::pair</code>, you must <code>#include</code> it. <code>std::pair</code> is defined in a header file called <code>utility</code></p> <pre><code>#include &lt;utility&gt;\n\nstd::pair&lt;double, double&gt; p { 1.0, 2.0 };\n\nnamespace std {\n    template\n    &lt;typename T1, typename T2&gt;\n    struct pair {\n        T1 first;\n        T2 second;\n    };\n}\n</code></pre>"},{"location":"Fundamental%20Programming/CS106L/types-and-structs/#the-using-keyword","title":"The using keyword","text":"<p>Typing out long type names gets tiring</p> <p>We can create type aliases with the <code>using</code> keyword</p> <pre><code>std::pair&lt;bool, std::pair&lt;double, double&gt;&gt; solveQuadratic(double a, double b, double c)\n\nusing Zeros = std::pair&lt;double, double&gt;;\nusing Solution = std::pair&lt;bool, Zeros&gt;;\n</code></pre>"},{"location":"Fundamental%20Programming/CS106L/types-and-structs/#the-auto-keyword","title":"The auto keyword","text":"<p>The auto keyword tells the compiler to infer the type</p> <pre><code>std::pair&lt;bool, std::pair&lt;double, double&gt;&gt; result = solveQuadratic(a, b, c);\n\nauto result = solveQuadratic(a, b, c);\n// This is exactly the same as the above!\n// result still has type std::pair&lt;bool, std::pair&lt;double, double&gt;&gt;\n// We just told the compiler to figure this out for us!\n</code></pre>"},{"location":"Fundamental%20Programming/CS61A/note/","title":"USB CS61A Note","text":""},{"location":"Fundamental%20Programming/CS61A/note/#higher-order-functions","title":"Higher-Order Functions","text":"<p>Higher-order functions are functions that either:</p> <ul> <li>Take one or more functions as arguments.</li> <li>Return a function as their result</li> </ul> <pre><code>def cube(k):\n    return pow(k, 3)\n\ndef summation(n, term):\n    \"\"\"Sum the first n terms of a sequence.\n\n    &gt;&gt;&gt; summation(5, cube)\n    225\n    \"\"\"\n\n    total, k = 0, 1\n    while k &lt;= n:\n        total, k = total + term(k), k + 1\n\n    return total\n</code></pre>"},{"location":"Fundamental%20Programming/CS61A/note/#function-composition","title":"Function Composition","text":"<p>Function composition is the process of combining two or more functions to create a new function.</p> <pre><code>def square(x):\n    return x * x\n\n\ndef triple(x):\n    return x * 3\n\n\ndef compose1(f, g):\n    def h(x):\n        return f(g(x))\n\n    return h\n\n\nprint(square(5))\nprint(triple(5))\n\n25\n15\n\nsquiple = compose1(square, triple)\nprint(squiple(5))\n\n225\n\ntripare = compose1(triple, square)\nprint(tripare(5))\n\n75\n</code></pre>"},{"location":"Fundamental%20Programming/CS61A/note/#lambda-functions","title":"Lambda functions","text":"<p>They're just...functions with different syntax. Lambda is a convenience feature to more easily define small, one-off functions.</p> <pre><code>square = lambda x: x * x\n\n(lambda x: x * x)(5)\n\ndef square(x):\n    return x * x\n</code></pre> <p>Only <code>def</code> statement give the function an intrinsic name.</p> <p><code>repr()</code> is a built-in function that returns a string representation of an object</p> <pre><code>repr(square)\n&lt;function &lt;lambda&gt; at 0x7fa3a158d300&gt;\n&lt;function square at 0x7fa3a158d3a0&gt;\n</code></pre>"},{"location":"Fundamental%20Programming/CS61A/note/#currying","title":"Currying","text":"<p>Transforming a multi-argument function into single-argument, higher-order function.</p> <p>Start with a function that takes multiple arguments -&gt; convert it into a series of nested functions:</p> <pre><code>f(a, b, c) \u2192 f(a)(b)(c)\n</code></pre> <pre><code>def add(x, y, z):\n    return x + y + z\n\ndef add(a):\n    return lambda b: lambda c: a + b + c\n\n# Usage\nresult = add(1)(2)(3)\nprint(result)\n</code></pre>"},{"location":"Fundamental%20Programming/CS61A/note/#decorators","title":"Decorators","text":"<p>Modify or enhance the behavior of functions or methods</p> <p>The best explanation of Python decorators</p> <p>In Python, <code>*args</code> and <code>**kwargs</code> are special syntax used to pass a variable number of arguments to a function. They allow you to handle an arbitrary number of positional and keyword arguments.</p> <ol> <li><code>*args</code>:</li> <li>Used to pass a variable number of positional arguments.</li> <li>When a function uses <code>*args</code>, it collects any extra positional arguments passed to the function and stores them as a tuple.</li> <li>For example:      <code>def func(*args):     print(args)  func(1, 2, 3)  # Output: (1, 2, 3)</code></li> <li>Here, <code>func(1, 2, 3)</code> passes three arguments, which are collected in <code>args</code> as a tuple <code>(1, 2, 3)</code>.</li> <li>**<code>**kwargs</code>**:</li> <li>Used to pass a variable number of keyword arguments.</li> <li>When a function uses <code>**kwargs</code>, it collects any extra keyword arguments as a dictionary.</li> <li>For example:      <code>def func(**kwargs):     print(kwargs)  func(a=1, b=2)  # Output: {'a': 1, 'b': 2}</code></li> <li>In this case, <code>func(a=1, b=2)</code> creates a dictionary <code>kwargs</code> containing the keys and values <code>{ 'a': 1, 'b': 2 }</code>.</li> </ol> <pre><code>def trace1(fn):\n    def traced(x):\n        print(\"Before the function call\")\n        result = print(fn(x))\n        print(\"After the function call\")\n        return result\n\n    return traced  # Ensure the wrapper function is returned\n\n\n# Original function\ndef square(x):\n    return x * x\n\n\n# Manually applying the decorator\ndecorated_square = trace1(square)\ndecorated_square(5)  # Output: Decorator applied manually\n\n\n# Using the decorator with @ syntax\n@trace1\ndef square_with_decorator(x):\n    return x * x\n\n\nsquare_with_decorator(5)  # Output: Decorator applied via @trace1\n</code></pre> <pre><code>@trace1\ndef triple(x):\n    return 3 * x\n</code></pre> <p>is identical to</p> <pre><code>def triple(x):\n    return 3 * x\ntriple = trace1(triple)\n</code></pre>"},{"location":"Fundamental%20Programming/CS61A/note/#recursive-functions","title":"Recursive Functions","text":"<p>A function is called recursive if the body of that function calls itself, either directly or indirectly</p> <ul> <li>The <code>def</code> statement header is similar to other functions</li> <li>Conditional statements check for base case</li> <li>Base cases are evaluated without recursive calls</li> <li>Recursive cases are evaluated with recursive calls</li> </ul> <pre><code>def factorial(n):\n    if n == 0:  # Base case\n        return 1\n    return n * factorial(n - 1)  # Recursive case\n</code></pre>"},{"location":"Fundamental%20Programming/CS61A/note/#tuples","title":"Tuples","text":"<p>Tuples are immutable sequences. Immutable values are protected from mutation.</p> <pre><code>t = (1, 2, 3)\n</code></pre>"},{"location":"Fundamental%20Programming/CS61A/note/#iterators","title":"Iterators","text":"<p>A container can provide an iterator that provides access to its elements in some order</p> <ul> <li><code>iter(iterable)</code>: Return an iterator over the elements of an iterable value</li> <li><code>next(iterator)</code>: Return the next element from an iterator</li> </ul> <pre><code>s = [1, 2, 3]\nt = iter(s)\nnext(t)  # 1\nnext(t)  # 2\n\nu = iter(s)\nnext (u)  # 1\nnext(t) # 3\n</code></pre> <p>The order of items in a dictionary is the order in which they were added (Python 3.6+). Historically, the order of items in a dictionary was arbitrary order (Python 3.5 and earlier).</p>"},{"location":"Fundamental%20Programming/CS61A/note/#built-in-functions-for-iterators","title":"Built-in Functions for Iterators","text":"<ul> <li><code>map(func, iterable)</code>: Iterate over func(x) for x in iterable</li> <li><code>filter(func, iterable)</code>: Iterate over x in iterable if func(x)</li> <li><code>zip(*iterables)</code>: Iterate over co-indexed (x, y) pairs</li> <li><code>reversed(sequence)</code>: Iterate over x in a sequence in reverse order</li> </ul> <p>To view the contents of an iterator, place the resulting elements into a container</p> <ul> <li>list(iterable): Create a list containing all x in iterable</li> <li>tuple(iterable): Create a tuple containing all x in iterable</li> <li>sorted(iterable): Create a sorted list containing all x in iterable</li> </ul> <pre><code>s = [1, 2, 3]\nlist(zip(s,reversed(s)))  # [(1, 3), (2, 2), (3, 1)]\n</code></pre>"},{"location":"Fundamental%20Programming/CS61A/note/#generators","title":"Generators","text":"<ul> <li>A generator function is a function that <code>yield</code>s values instead of <code>return</code>ing them.</li> <li>A normal function <code>return</code>s once; a generator function <code>yield</code>s multiple times.</li> <li>A generator is an iterator created automatically by a generator function.</li> <li>When a genreator function is called, it returns a generator that iterates over the <code>yield</code>ed values.</li> </ul> <pre><code>def evens(start, end):\n    # 2 = 1 + 1%2\n    even = start + (start % 2)\n    while even &lt;= end:\n        yield even\n        even += 2\n\n\nprint(list(evens(1, 10)))\n\n# [2, 4, 6, 8, 10]\n\nt = evens(2, 10)\nprint(next(t))\n# 2\nprint(next(t))\n# 4\n</code></pre>"},{"location":"Fundamental%20Programming/CS61A/note/#string-representations","title":"String Representations","text":"<p>The <code>repr</code> function returns a Python expression (a string) that evaluates to an equal object</p> <pre><code>repr(object) -&gt; string\n\nReturn the canonical string representation of the object.\nFor most object types, eval(repr(object)) == object.\n</code></pre> <p>The result of calling <code>repr</code> on a value is what Python prints in an interactive session.</p> <p>In Python, all objects produce two string representations: \u2022 The <code>str</code> is legible to humans \u2022 The <code>repr</code> is legible to the Python interpreter The str and repr strings are often the same, but not always</p> <pre><code>&gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; half = Fraction(1, 2)\n&gt;&gt;&gt; str(half)\n'1/2'\n&gt;&gt;&gt; repr(half)\n'Fraction(1, 2)'\n</code></pre>"},{"location":"Fundamental%20Programming/CS61A/note/#string-interpolation","title":"String Interpolation","text":"<p>String interpolation involves evaluating a string literal that contains expressions.</p> <p>Using string concatenation:</p> <pre><code>&gt;&gt;&gt; from match import pi\n&gt;&gt;&gt; 'pi starts with' + str(pi) + '...'\n'pi starts with 3.14159...'\n\n&gt;&gt;&gt; print('pi start with' + str(pi) + '...')\npi starts with 3.14159...\n</code></pre> <p>Using string interpolation:</p> <pre><code>&gt;&gt;&gt; f'pi starts with {pi}...'\n'pi starts with 3.14159...'\n</code></pre>"},{"location":"Fundamental%20Programming/CS61A/note/#class-attributes","title":"Class Attributes","text":"<p>Class attributes are shared among all instances of a class because they are attributes of the class itself, not of the instances.</p> <pre><code>class Account:\n    interest = 0.02  # A class attribute\n\n    def __init__(self, account_holder):\n        self.balance = 0\n        self.holder = account_holder\n\n    def deposit(self, amount):\n        self.balance = self.balance + amount\n        return self.balance\n</code></pre>"},{"location":"Fundamental%20Programming/CS61A/note/#polymorphic-function","title":"Polymorphic function","text":"<p>A function that applies to many (poly) differents forms (morph) of data</p> <p><code>str</code> and <code>repr</code> are both polymorphic; they apply to any object</p> <p><code>repr</code> invokes a zero-arugment method <code>__repr__</code> on its argument</p> <p><code>str</code> invokes a zero-argument method <code>__str__</code> on its argument</p> <p>The behavior of <code>repr</code> is slightly more complicated than invoking <code>__repr__</code> on its argument</p> <ul> <li>An instance attribute called repr is ignored!. Only class attributes are found</li> </ul> <pre><code>def repr(x):\n    return type(x).__repr__(x)\n</code></pre> <ul> <li>An instance attribute called <code>__str__</code> is ignored.</li> <li>If no <code>__str__</code> attribute is found, use <code>repr</code> string</li> </ul>"},{"location":"Fundamental%20Programming/CS61A/note/#interfaces","title":"Interfaces","text":"<p>Message passing: Objects interact by looking up attributes on each other (passing messages)</p> <p>The attribute look-up rules allow different data types to respond to the same messaage.</p> <p>A share message (attribute name) that elicits similar behavior from different object classes is a powerful method of abstraction</p> <p>An interface is a set of shared messages, along with a specification of what they mean</p> <pre><code>from abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n\n    @abstractmethod\n    def perimeter(self):\n        pass\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return 3.14 * self.radius ** 2\n\n    def perimeter(self):\n        return 2 * 3.14 * self.radius\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def area(self):\n        return self.width * self.height\n\n    def perimeter(self):\n        return 2 * (self.width + self.height)\n</code></pre>"},{"location":"Fundamental%20Programming/CS61A/note/#special-methods-names-in-python","title":"Special Methods Names in Python","text":"<ul> <li><code>__init__</code>: Method invoked automatically when an object is constructed</li> <li><code>__repr__</code>: Method invoked to display an object as a Python expression</li> <li><code>__add__</code>: Method invoked to add one object to another</li> <li><code>__bool__</code>: Method invoked to convert an object to True or False</li> <li><code>__float__</code>: Method invoked to convert an object to a float (real number)</li> </ul> <pre><code>one + two\nbool(one)\n# same behavior\none.__add__(two)\none.__bool__()\n</code></pre>"},{"location":"Fundamental%20Programming/CS61A/note/#declarative-programming","title":"Declarative Programming","text":"<p>In declarative languages such as SQL &amp; Prolog:</p> <ul> <li>A program is a description of the desired result</li> <li>The interpreter figures out how to generate the result</li> </ul> <p>In imperative languages such as Python &amp; Scheme:</p> <ul> <li>A program is a description of computational processes</li> <li>The interpreter carries out execution/evaluation rules</li> </ul>"},{"location":"Misc/dsa-junmin/","title":"Data Structures [Junmin Lee]","text":"<p>This post is based on Data Structures in Golang by Junmin Lee</p>"},{"location":"Misc/dsa-junmin/#data-structures-junmin-lee","title":"Data Structures [Junmin Lee]","text":""},{"location":"Misc/dsa-junmin/#linked-list","title":"Linked List","text":"<p>Linked List put the values in nodes. Nodes are linked to each other by containing address of the next nodes.</p> <p>Benefits:</p> <ul> <li>Adding or removing values at the beginning of the list: O(1). Array need to shift when adding new values.</li> </ul> <p>Disadvantages</p> <ul> <li>Travel and replace the value of the node: 0(n), arrays cost just O(1)</li> </ul>"},{"location":"Misc/dsa-junmin/#doubly-linked-list","title":"Doubly linked list","text":"<p>Contains the address of the next and also the previous node</p>"},{"location":"Misc/dsa-junmin/#implement","title":"Implement","text":"<pre><code>package main\n\nimport \"fmt\"\n\ntype node struct {\n    data int\n    next *node\n}\n\ntype linkedList struct {\n    head   *node\n    length int\n}\n\nfunc (l *linkedList) prepend(n *node) {\n    second := l.head\n    l.head = n\n    l.head.next = second\n    l.length++\n}\n\nfunc (l linkedList) printListData() {\n    toPrint := l.head\n    for l.length != 0 {\n        fmt.Printf(\"%d \", toPrint.data)\n        toPrint = toPrint.next\n        l.length--\n    }\n    fmt.Println(\"\\n\")\n}\n\nfunc (l *linkedList) deleteWithValue(value int) {\n    if l.length == 0 {\n        return\n    }\n    if l.head.data == value {\n        l.head = l.head.next\n        l.length--\n        return\n    }\n\n    previousToDelete := l.head\n    for previousToDelete.next.data != value {\n        if previousToDelete.next.next == nil {\n            return\n        }\n        previousToDelete = previousToDelete.next\n    }\n    previousToDelete.next = previousToDelete.next.next\n    l.length--\n}\nfunc main() {\n    mylist := linkedList{}\n    node1 := &amp;node{data: 6}\n    node2 := &amp;node{data: 5}\n    node3 := &amp;node{data: 4}\n    node12 := &amp;node{data: 3}\n    node22 := &amp;node{data: 2}\n    node32 := &amp;node{data: 1}\n    mylist.prepend(node1)\n    mylist.prepend(node2)\n    mylist.prepend(node3)\n    mylist.prepend(node12)\n    mylist.prepend(node22)\n    mylist.prepend(node32)\n    fmt.Println(mylist)\n    mylist.printListData()\n    mylist.deleteWithValue(6)\n    mylist.deleteWithValue(7)\n    mylist.deleteWithValue(1)\n    mylist.printListData()\n    emptylist := linkedList{}\n    emptylist.deleteWithValue(10)\n}\n</code></pre> <pre><code>{0xc0000522a0 6}\n1 2 3 4 5 6\n\n2 3 4 5\n</code></pre>"},{"location":"Misc/dsa-junmin/#stacks","title":"Stacks","text":"<ul> <li>Last in first out (LIFO)</li> <li>Add: Push. Remove: Pop</li> </ul>"},{"location":"Misc/dsa-junmin/#implement_1","title":"Implement","text":"<pre><code>package main\n\nimport \"fmt\"\n\ntype Queue struct {\n    items []int\n}\n\n// Push will add value at the end\nfunc (s *Queue) Push(i int) {\n    s.items = append(s.items, i)\n}\n\n// Pop will remove a value at the end\n// End return the removed value\nfunc (s *Queue) Pop() int {\n\n    // a[low : high]\n    // This selects a half-open range which includes the first element, but excludes the last one.\n    l := len(s.items) - 1\n    toRemove := s.items[l]\n    s.items = s.items[:l]\n    return toRemove\n}\n\nfunc main() {\n    myStack := Queue{}\n    myStack.Push(100)\n    myStack.Push(200)\n    myStack.Push(300)\n    fmt.Println(myStack)\n    myStack.Pop()\n    fmt.Println(myStack)\n}\n</code></pre> <pre><code>{[100 200 300]}\n{[100 200]}\n</code></pre>"},{"location":"Misc/dsa-junmin/#queues","title":"Queues","text":"<ul> <li>First in first out</li> <li>Add : Enqueue. Remove: Deque</li> </ul>"},{"location":"Misc/dsa-junmin/#implement_2","title":"Implement","text":"<pre><code>package main\n\nimport \"fmt\"\n\ntype Queue struct {\n    items []int\n}\n\n// Push will add value at the end\nfunc (q *Queue) Enqueue(i int) {\n    q.items = append(q.items, i)\n}\n\n// Pop will remove a value at the end\n// End return the removed value\nfunc (q *Queue) Deque() int {\n    toRemove := q.items[0]\n    q.items = q.items[1:]\n    return toRemove\n}\n\nfunc main() {\n    myQueue := Queue{}\n    myQueue.Enqueue(100)\n    myQueue.Enqueue(200)\n    myQueue.Enqueue(300)\n    fmt.Println(myQueue)\n    myQueue.Deque()\n    fmt.Println(myQueue)\n}\n</code></pre> <pre><code>{[100 200 300]}\n{[200 300]}\n</code></pre>"},{"location":"Misc/dsa-junmin/#binary-search-tree","title":"Binary Search Tree","text":"<p>Root -&gt; Parent -&gt; Children -&gt; Leaf</p> <p>Left Children smaller, Right Children bigger</p> <p>Benefits:</p> <ul> <li>Speed</li> <li>O(logn)</li> <li>Worst case still 0(n)</li> </ul>"},{"location":"Misc/dsa-junmin/#implement_3","title":"Implement","text":"<pre><code>package main\n\nimport \"fmt\"\n\nvar count int // Count how many nodes travel\n\ntype Node struct {\n    Key   int\n    Left  *Node\n    Right *Node\n}\n\nfunc (n *Node) Insert(k int) {\n    if n.Key &lt; k {\n        //move right\n        if n.Right == nil {\n            n.Right = &amp;Node{Key: k}\n        } else {\n            n.Right.Insert(k)\n        }\n    } else if n.Key &gt; k {\n        //move left\n        if n.Left == nil {\n            n.Left = &amp;Node{Key: k}\n        } else {\n            n.Left.Insert(k)\n        }\n    }\n}\n\n// Search will take in a key value\n// and Return Trueif there is a node with that value\n\nfunc (n *Node) Search(k int) bool {\n    count++\n    if n == nil {\n        return false\n    }\n    if n.Key &lt; k {\n        n.Right.Search(k)\n\n    } else if n.Key &gt; k {\n        n.Left.Search(k)\n    }\n    return true\n}\nfunc main() {\n    tree := &amp;Node{Key: 100}\n    tree.Insert(200)\n    tree.Insert(50)\n    tree.Insert(202)\n    tree.Insert(50)\n    tree.Insert(24120)\n    tree.Insert(525)\n    tree.Insert(15)\n    tree.Insert(5213)\n    tree.Insert(230)\n    tree.Insert(5)\n    tree.Insert(8)\n\n    fmt.Println(tree)\n    fmt.Println(tree.Search(5213))\n    fmt.Println(count)\n}\n</code></pre> <pre><code>&amp;{100 0xc0000080a8 0xc000008090}\ntrue\n6\n</code></pre>"},{"location":"Misc/dsa-junmin/#tries","title":"Tries","text":"<p>Trees that store words.</p> <p>Each nodes hold the array of 26 characters.</p> <p>Time complexity: 0(m), where m is the length of the words/</p> <p>Return false immediately if the words not in the tree (the first character of the words not in the first parents)</p> <p>Tries is trade off between Time and Space.</p>"},{"location":"Misc/dsa-junmin/#implement_4","title":"Implement","text":"<pre><code>package main\n\nimport \"fmt\"\n\n// AlphabetSize is the numberof possible characters in the trie\n\nconst AlphabetSize = 26\n\ntype TrieNode struct {\n    children [AlphabetSize]*TrieNode\n    isEnd    bool\n}\n\n// Trie represent a trie and has a pointer to the root node\ntype Trie struct {\n    root *TrieNode\n}\n\nfunc InitTrie() *Trie {\n    results := &amp;Trie{root: &amp;TrieNode{}}\n    return results\n}\n\n// Insert will take in a word and add it to the tries\nfunc (t *Trie) Insert(w string) {\n    wordLength := len(w)\n    currentNode := t.root\n    for i := 0; i &lt; wordLength; i++ {\n        charIndex := w[i] - 'a' // 'a' = 97. 'b' - 'a' = 1 =&gt; a 0 b 1 c 2 ...\n        if currentNode.children[charIndex] == nil {\n            currentNode.children[charIndex] = &amp;TrieNode{}\n        }\n        currentNode = currentNode.children[charIndex]\n    }\n    currentNode.isEnd = true\n}\n\n// Search will take in a word and return TRUE if that word is include in the trie\nfunc (t *Trie) Search(w string) bool {\n    wordLength := len(w)\n    currentNode := t.root\n    for i := 0; i &lt; wordLength; i++ {\n        charIndex := w[i] - 'a' // 'a' = 97. 'b' - 'a' = 1 =&gt; a 0 b 1 c 2 ...\n        if currentNode.children[charIndex] == nil {\n            return false\n        }\n        currentNode = currentNode.children[charIndex]\n    }\n    if currentNode.isEnd == true {\n        return true\n    }\n    return false // Even will match the word, but the word can continue =&gt; not the word we want\n}\n\nfunc main() {\n    testTrie := InitTrie()\n    fmt.Println(testTrie)      //&amp;{0xc000138000}\n    fmt.Println(testTrie.root) // &amp;{[&lt;nil&gt; x26 ] false}\n    toAdd := []string{\n        \"test\",\n        \"next\",\n        \"best\",\n        \"aragon\",\n        \"oregon\",\n    }\n\n    for _, v := range toAdd {\n        testTrie.Insert(v)\n    }\n    fmt.Println(testTrie.Search(\"aragon\"))\n}\n</code></pre> <pre><code>&amp;{0xc00010e000}\n&amp;{[&lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt;] false}\n&amp;{[0xc00010ec40 0xc00010e8c0 &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; 0xc00010e540 0xc00010f180 &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; 0xc00010e1c0 &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt;] false}\ntrue\n</code></pre>"},{"location":"Misc/dsa-junmin/#hash-tables","title":"Hash Tables","text":""},{"location":"Misc/dsa-junmin/#introduction","title":"Introduction","text":"<p>Search for the name in the array =&gt; You have to go through all the array to search for it.</p> <p>But if you know the index (hash code) of the name, for example, 82 for Andy =&gt; You can immediately access the name.</p> <p>When Inserting, but Andy into the Hash function, get the hash code, and go to that index to find Andy.</p>"},{"location":"Misc/dsa-junmin/#simple-hash-algorithm","title":"Simple Hash Algorithm","text":"<p>RANDY =&gt; 82 + 65 + 78 + 68 + 89 (ASCII Code) = 382</p> <p>382 % 100 = 82.</p> <p>Choose 100 because is the size of the array we want to store. So the index always between 0 and 99</p> <p>Eric -&gt; 91.</p> <p>When we search for STAN, we put into the hash function =&gt; get the index and find it in the array</p>"},{"location":"Misc/dsa-junmin/#collision-handling","title":"Collision Handling","text":"<p>Two name have the same hash code. There are two ways for collision handling</p> <p>First is Open Addressing. We store Andy in index 4 and Eric in index 5. When we search for Eric, we go to the original location, which is 4. If 4 is not Eric, we go to the next index, which is 5. This method still faster than searching each element in the array.</p> <p>Drawbacks: more and more name in the same address =&gt; loose benefit of the hash table.</p> <p>Second is Separate Chaining: Storing multiple names in one slot by using Linked List. Each index will hold a pointer point to the head of a linked list. That has a list of name. The linked list will be called bucket.</p>"},{"location":"Misc/dsa-junmin/#insertdeletesearch","title":"Insert/Delete/Search","text":"<p>Hash table has the best of array and linked list.</p> <p>Best case: 0(1) for Insert Delete and Search</p> <p>Worst Case: 0(n) like a linked list when every element in the same linked list.</p>"},{"location":"Misc/dsa-junmin/#implement_5","title":"Implement","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\n// ArraySize is the size of the hash table array\n\nconst ArraySize = 7\n\n// HashTable will hold an array\n\ntype HashTable struct {\n    array [ArraySize]*bucket\n}\n\n// bucket is a linked list in each slot of the array\n\ntype bucket struct {\n    head *bucketNode\n}\n\n// bucketNode structure\ntype bucketNode struct {\n    key  string\n    next *bucketNode\n}\n\n// Insert will take in a key and add it to the hash table array\n\nfunc (h *HashTable) Insert(key string) {\n    index := hash(key)\n    h.array[index].insert(key)\n}\n\n// Search will take in a key and add it to the hash table array\n\nfunc (h *HashTable) Search(key string) bool {\n    index := hash(key)\n    return h.array[index].search(key)\n}\n\n// Delete will take in a key and delete it from the hash table\n\nfunc (h *HashTable) Delete(key string) {\n    index := hash(key)\n    h.array[index].delete(key)\n}\n\n// Init will create a bucket in each slot of the hash table\n\nfunc Init() *HashTable {\n    result := &amp;HashTable{}\n    for i := range result.array {\n        result.array[i] = &amp;bucket{}\n    }\n    return result\n}\n\n// insert will take in a key, create a node with a key\n// and insert the node in the bucket\n\nfunc (b *bucket) insert(k string) {\n    if !b.search(k) {\n        newNode := &amp;bucketNode{key: k}\n        newNode.next = b.head\n        b.head = newNode\n    } else {\n        fmt.Println(k, \"already exists\")\n    }\n}\n\n// search will take in a key and return true if the bucket has that key\n\nfunc (b *bucket) search(k string) bool {\n    currentNode := b.head\n    for currentNode != nil {\n        if currentNode.key == k {\n            return true\n        }\n        currentNode = currentNode.next\n    }\n    return false\n}\n\n// delete will take in a key and delete the node from the bucket\n\nfunc (b *bucket) delete(k string) {\n\n    if b.head.key == k {\n        b.head = b.head.next\n        return\n    }\n    previousNode := b.head\n    for previousNode.next != nil {\n        if previousNode.next.key == k {\n            previousNode.next = previousNode.next.next\n        }\n        previousNode = previousNode.next\n    }\n}\n\n// hash\nfunc hash(key string) int {\n    sum := 0\n    for _, v := range key {\n        sum += int(v)\n    }\n    return sum % ArraySize\n}\n\nfunc main() {\n    testHashTable := Init()\n    list := []string{\n        \"ERIC\",\n        \"KENNY\",\n        \"KYLE\",\n        \"STAN\",\n        \"RANDY\",\n        \"BUTTERS\",\n        \"TOKEN\",\n    }\n\n    for _, v := range list {\n        testHashTable.Insert(v)\n    }\n\n    testHashTable.Delete(\"STAN\")\n    fmt.Println(testHashTable.Search(\"STAN\"))\n    fmt.Println(testHashTable.Search(\"KYLE\"))\n\n    testBucket := &amp;bucket{}\n    testBucket.insert(\"RANDY\")\n    testBucket.insert(\"RANDY\")\n    testBucket.delete(\"RANDY\")\n    fmt.Println(testBucket.search(\"RANDY\"))\n    fmt.Println(testBucket.search(\"ERIC\"))\n}\n</code></pre> <pre><code>false\ntrue\nRANDY already exists\nfalse\nfalse\n</code></pre>"},{"location":"Misc/dsa-junmin/#heap","title":"Heap","text":"<p>The parent node is larger than a child.</p> <ul> <li>parent index * 2 + 1 = left child index.</li> <li>parent index * 2 + 2 = right child index</li> </ul> <p>Very fast when getting the biggest or lowest value (highest node).</p>"},{"location":"Misc/dsa-junmin/#insert","title":"Insert","text":"<p>When ever insert: add the node to the bottom right of the tree.</p>"},{"location":"Misc/dsa-junmin/#heapify","title":"Heapify","text":"<p>We need to re-arrange the tree by swapping the parent and child nodes if the child node is larger than the parent node. The process of rearranging the indices as Heapify.</p>"},{"location":"Misc/dsa-junmin/#extract","title":"Extract","text":"<p>Extract means remove the highest key of the tree. Right after taking out the highest nodes, we will take the last node of the tree to the root position. Then we swap with its larger child.</p>"},{"location":"Misc/dsa-junmin/#time-complexity","title":"Time complexity","text":"<p>Heapify up or down is depending on the height of the tree =&gt; 0(h) (extract or insert)</p> <p>If you want to replace to it the number of elements of the array =&gt; O(logn) because the height and the number of indices have a logarithmic relation.</p>"},{"location":"Misc/dsa-junmin/#implement_6","title":"Implement","text":"<pre><code>package main\n\nimport \"fmt\"\n\n// MaxHeap struct has a slice that holds the array\ntype MaxHeap struct {\n    array []int\n}\n\n// Insert adds an element to the heap\nfunc (h *MaxHeap) Insert(key int) {\n    h.array = append(h.array, key)\n    h.maxHeapifyUp(len(h.array) - 1)\n}\n\n// Extract returns the largest key, and removes it from the heap.\nfunc (h *MaxHeap) Extract() int {\n    extracted := h.array[0]\n    l := len(h.array) - 1\n\n    if len(h.array) == 0 {\n        fmt.Print(\"cannot extract because array length is 0\")\n        return -1\n    }\n\n    h.array[0] = h.array[l]\n    h.array = h.array[:l]\n\n    h.maxHeapifyDown(0)\n    return extracted\n}\n\n// maxHeapifyUp will heapify from bottom top\nfunc (h *MaxHeap) maxHeapifyUp(index int) {\n    for h.array[parent(index)] &lt; h.array[index] {\n        h.swap(parent(index), index)\n        index = parent(index)\n    }\n}\n\n// maxHeapifyDown will be heapify top to bottom\nfunc (h *MaxHeap) maxHeapifyDown(index int) {\n\n    // loop while index at least one child\n    lastIndex := len(h.array) - 1\n    l, r := left(index), right(index)\n    childToCompare := 0\n    for l &lt;= lastIndex {\n        if l == lastIndex {\n            // when left child is the only child\n            childToCompare = l\n        } else if h.array[l] &gt; h.array[r] {\n            //when left child is larger\n            childToCompare = l\n        } else {\n            // when right child is larger\n            childToCompare = r\n        }\n\n        // compare array value of current index\n        // to larger child and swap if smaller\n\n        if h.array[index] &lt; h.array[childToCompare] {\n            h.swap(index, childToCompare)\n            index = childToCompare\n            l, r = left(index), right(index)\n        } else {\n            // it means it find the right place\n            return\n        }\n\n    }\n}\n\n// get the parent index\nfunc parent(i int) int {\n    return (i - 1) / 2\n}\n\n// get the left child index\nfunc left(i int) int {\n    return 2*i + 2\n}\n\n// get the right child index\nfunc right(i int) int {\n    return 2*i + 1\n}\n\n// swap keys in the array\nfunc (h *MaxHeap) swap(i1, i2 int) {\n    h.array[i1], h.array[i2] = h.array[i2], h.array[i1]\n}\n\nfunc main() {\n    m := &amp;MaxHeap{}\n    fmt.Println(m)\n    buildHeap := []int{10, 20, 30, 5, 7, 9, 11, 13, 15, 17}\n    for _, v := range buildHeap {\n        m.Insert(v)\n        fmt.Println(m)\n    }\n\n    for i := 0; i &lt; 5; i++ {\n        m.Extract()\n        fmt.Println(m)\n    }\n}\n</code></pre> <pre><code>&amp;{[]}\n&amp;{[10]}\n&amp;{[20 10]}\n&amp;{[30 10 20]}\n&amp;{[30 10 20 5]}\n&amp;{[30 10 20 5 7]}\n&amp;{[30 10 20 5 7 9]}\n&amp;{[30 10 20 5 7 9 11]}\n&amp;{[30 13 20 10 7 9 11 5]}\n&amp;{[30 15 20 13 7 9 11 5 10]}\n&amp;{[30 17 20 13 15 9 11 5 10 7]}\n&amp;{[20 17 11 13 15 9 7 5 10]}\n&amp;{[17 15 11 13 10 9 7 5]}\n&amp;{[15 13 11 5 10 9 7]}\n&amp;{[13 10 11 5 7 9]}\n&amp;{[11 10 9 5 7]}\n</code></pre>"},{"location":"Misc/dsa-junmin/#graph","title":"Graph","text":""},{"location":"Misc/dsa-junmin/#adjacency-matrix-vs-adjacency-list","title":"Adjacency Matrix vs Adjacency List:","text":"<p>V is a number of vertices Space</p> <p>You always need V square space where V is a number of vertices.</p> <p>Edge Lookup</p> <p>Constant time for Matrix because we just need to do the array look up.</p> <p>For List you need to travel a list of adjacent vertices which in the worst case it would need v step.</p> <p>Add vertex</p> <p>Easy in List because we just need an element to list.</p> <p>But in Matrix we need to copy the whole array to add new dimensions to the matrix.</p> <p>Remmove vertex</p> <p>Same with add vertex. We need to copy the array to have a new array.</p> <p>Add Edge</p> <p>Both constant time</p> <p>Delete Edge Same for add edge for matrix. But for ad-list, you need to travel to find the edge =&gt; 0(V)</p> <p></p>"},{"location":"Misc/dsa-junmin/#implement_7","title":"Implement","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\n// Graph represents an adjacency list graph\ntype Graph struct {\n    vertices []*Vertex\n}\n\n// Vertex represent sgraph vertex\ntype Vertex struct {\n    key      int\n    adjacent []*Vertex\n}\n\n// Add Vertex to the Graph\nfunc (g *Graph) AddVertex(k int) {\n    if contains(g.vertices, k) {\n        err := fmt.Errorf(\"Vertex %v not added because it is an existing key\", k)\n        fmt.Println(err.Error())\n    } else {\n        g.vertices = append(g.vertices, &amp;Vertex{key: k})\n    }\n}\n\n// AddEdge adds an edge to the graph\nfunc (g *Graph) AddEdge(from, to int) {\n    // get vertex\n    fromVertex := g.getVertex(from)\n    toVertex := g.getVertex(to)\n    // check error\n    // check if either from or to vertex not exist\n    if fromVertex == nil || toVertex == nil {\n        err := fmt.Errorf(\"Invalid edge (%v --&gt;%v)\", from, to)\n        fmt.Println(err.Error())\n    } else if contains(fromVertex.adjacent, to) {\n        err := fmt.Errorf(\"Existing edge (%v --&gt;%v)\", from, to)\n        fmt.Println(err.Error())\n    } else {\n        // add edge\n        fromVertex.adjacent = append(fromVertex.adjacent, toVertex)\n    }\n}\n\n// GetVertex returns a pointer to the Vertex with a key integer\n\nfunc (g *Graph) getVertex(k int) *Vertex {\n    for i, v := range g.vertices {\n        if v.key == k {\n            return g.vertices[i]\n        }\n    }\n    return nil\n}\n\n// contains\nfunc contains(s []*Vertex, k int) bool {\n    for _, v := range s {\n        if k == v.key {\n            return true\n        }\n    }\n    return false\n}\n\n// Print will print the adjacent list for each vertex of the graph\nfunc (g *Graph) Print() {\n    for _, v := range g.vertices {\n        fmt.Printf(\"\\nVertex %v : \", v.key)\n        for _, v := range v.adjacent {\n            fmt.Printf(\"%v \", v.key)\n        }\n    }\n}\n\nfunc main() {\n    test := &amp;Graph{}\n\n    for i := 0; i &lt; 5; i++ {\n        test.AddVertex(i)\n    }\n\n    test.AddVertex(0)\n    test.AddVertex(0)\n\n    test.AddEdge(1, 2)\n    test.AddEdge(6, 2)\n    test.AddEdge(1, 2)\n    test.AddEdge(2, 4)\n    test.AddEdge(1, 3)\n\n    test.Print()\n}\n</code></pre> <pre><code>Vertex 0 not added because it is an existing key\nVertex 0 not added because it is an existing key\nInvalid edge (6 --&gt;2)\nExisting edge (1 --&gt;2)\n\nVertex 0 :\nVertex 1 : 2 3\nVertex 2 : 4\nVertex 3 :\nVertex 4 :\n</code></pre>"},{"location":"Misc/dsa-junmin/#pointers","title":"Pointers","text":"<p>*:</p> <ul> <li><code>*int</code>: this whole thing is a type(pointer type, <code>int</code> is a base)</li> <li><code>*p</code>: * in front of variable =&gt; operator returns what p is pointing to (print value the pointer pointing to - dereferencing)</li> <li>value of p is now the address of the value</li> </ul> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n i, j := 42, 2701\n\n p := &amp;i\n fmt.Println(*p) // 42\n fmt.Printf(\"%T\\n\", p)\n *p = 21        // change value of i, still keep the address of i\n fmt.Println(i) // print 21\n\n p = &amp;j         // now point to j\n *p = *p / 37   // change value of j, still keep the address of j\n fmt.Println(j) // 73\n}\n</code></pre> <p>Why you pointer? Because you can access the variable through pointer from different part of the program rather than copy it each time you use or want to manipulate.</p> <p>Goroutines: independent path of execution - stack of memory</p> <pre><code>func main(){\n    a :=4\n    squareVal(a)\n}\n\nfunc squareVal(v int)  {\n    v *= v\n    fmt.Println(&amp;v,v)\n}\n</code></pre> <p></p> <p>They are isolated frames.</p> <p>After squareVal create a copy of <code>a</code> =&gt; <code>v</code> with value of 16, when the active frame return to main, <code>a</code> still has the value of 4.</p> <pre><code>func main(){\n    a :=4\n    squareAdd(&amp;a)\n}\n\nfunc squareAdd(p *int){\n    *p *= *p\n    fmt.Println(p,*p)\n}\n</code></pre> <p></p>"},{"location":"Misc/dsa-junmin/#return-m-value-and-m-pointer","title":"return <code>m</code> (value) and <code>&amp;m</code> (pointer)","text":"<pre><code>package main\n\nimport \"fmt\"\n\ntype person struct {\n    name string\n    age  int\n}\n\nfunc initPerson() person {\n    m:= person{name:\"noname\", age:50}\n    return m\n}\n\nfunc main()  {\n    fmt.Println(initPerson())\n}\n</code></pre> <p>When we call initPerson, we create <code>m</code>. Then you change the value of <code>m</code>, because of the isolation characteristic. We can not send <code>m</code> to the <code>main()</code> function. Instead, we make a copy of <code>m</code>.</p> <p></p> <p>Let's return the address of <code>m</code></p> <pre><code>func initPerson() *person {\n       m:= person{name:\"noname\", age:50}\n       fmt.Printf(\"initPerson -&gt; %p\\n\",&amp;m)\n       return &amp;m\n}\n\nfunc main()  {\n    fmt.Println(initPerson())\n    fmt.Printf(\"main -&gt; %p\\n\",initPerson())\n}\n</code></pre> <p></p> <p>We have an address pointing to <code>m</code>, but when the <code>initPerson()</code> function finish. That frame is become invalid so the address we copied into the active frame is useless. That where heaps come in so heaps is going to solve this problem for us. The name heaps is different from data structure heaps.</p> <p>The compiler will analyze what's going on and figures out that this may cause the problem and copy <code>m</code> to the heap. Then the <code>initPerson()</code> function will return the address of <code>m</code> in the heap. After the return when the address of <code>m</code> is copied to the frame of the <code>main()</code> function. We would be able to access 'm` with that address.</p> <p></p>"},{"location":"Misc/dsa-junmin/#garbage-collector","title":"Garbage Collector","text":"<p>We are doing this in the cost of heap allocation. Which can be a burden for the garbage collector and it can cost us performance.</p> <p>Stacks don't need garbage collector because it is self-cleaning. When function is called and finish, it will discards the frame and everything inside it. When another function is called, the space will be used by other frames.</p> <p>If we put something in the heap, that will create job for the garbage collector.</p> <p>There is a specific algorithms for the garbage collector automatically sets the memory free for ones that we don't use and just keep the ones that we need.</p> <p></p>"},{"location":"Misc/dsa-junmin/#few-notes","title":"Few notes","text":"<p>Few notes from Golang Tutorial 2 - Learn how go works with the hello world code by Junmin Lee</p> <p>C++, Go, Java, Python: High Level Languages, which means human-readable.</p> <p>Human -&gt; Machine: Compile (Convert human to machine-readable code).</p> <p>For example, when finishing a program, compiler will transform it to an executable file (file.exe).</p> <p>A package is a collection of source files in the same directory that are compiled together.</p> <p>A module is a collection of related go packages that are released together.</p>"},{"location":"Misc/dsa-junmin/#references","title":"References","text":"<ul> <li>Data Structures in Golang by Junmin Lee</li> </ul>"},{"location":"Misc/learning-go/","title":"Learning Go","text":"<p>This post includes information that I found interesting or important while reading the Learning Go book by John Bodner.</p>"},{"location":"Misc/learning-go/#chapter-2-primitive-types-and-declarations","title":"Chapter 2. Primitive Types and Declarations","text":""},{"location":"Misc/learning-go/#built-in-types","title":"Built-in Types","text":"<p>Integer literals are normally base ten, but different prefixes are used to indicate other bases: <code>0b</code> for binary (base two), <code>0o</code> or leading 0 with no letter follow for octal (base eight), or <code>0x</code> for hexadecimal (base sixteen).</p> <p>Rune literals represent characters and are surrounded by single quotes. In Go, Single quotes and double quotes are not interchangeable. Rune literals can be written as single Unicode characters <code>'a'</code>, 8-bit octal numbers <code>'\\141'</code>, 8-bit hexadecimal numbers <code>'\\x61'</code>, etc.</p> <p>A byte is an alias for uint8. Note: Uint8 value range is 0 to 255 and int8 range is -128 to 127 (-128: 10000000 (1 is a sign bit), 127: 01111111).</p> <p>An int (or unit). On a 32-bit or 64-bit CPU, <code>int</code> is a 32-bit or 64-bit signed integer like an int32 or int64.</p> <p>Float: float32 and float64. While Go lets you use <code>==</code> and <code>!=</code> to compare floats, don\u2019t do it. Instead, define a maximum allowed variance and see if the difference between two floats is less than that.</p> <p>Strings in Go are immutable; you can reassign the value of a string variable, but you cannot change the value of the string that is assigned to it.</p> <p>The rune type is an alias for the int32 type.</p>"},{"location":"Misc/learning-go/#var-versus","title":"var Versus :=","text":"<pre><code>var x int = 10\nvar x = 10\nvar x int\nx:= 10\n</code></pre> <p>Situations within functions where you should avoid <code>:=</code>:</p> <ul> <li>When initializing a variable to its zero value, use <code>var x int</code>. This makes it clear that the zero value is intended.</li> <li>specify the type of the value: <code>x := byte(20)</code>, it is idiomatic to write <code>var x byte = 20</code></li> </ul>"},{"location":"Misc/learning-go/#typed-and-untyped-constants","title":"Typed and Untyped Constants","text":"<p>Constants can be typed or untyped. All of the following assignments are legal:</p> <pre><code>const x = 10\nvar y float = x\nvar z byte = x\n</code></pre>"},{"location":"Misc/learning-go/#naming-variables-and-constants","title":"Naming Variables and Constants","text":"<p>The names <code>k</code> and <code>v</code> (short for key and value) are used as the variable names in a <code>for-range</code> loop, standard for loop: <code>i</code> and <code>j</code> are common names for the index variable. People will use the first letter of a type (for example, <code>i</code> for integers, <code>f</code> for floats, <code>b</code> for booleans).</p>"},{"location":"Misc/learning-go/#chapter-3-composite-types","title":"Chapter 3. Composite Types","text":""},{"location":"Misc/learning-go/#arrays","title":"Arrays","text":"<pre><code>var x = [12]int{1, 5: 4, 6, 10: 100, 15}\n</code></pre> <p>This creates an array of 12 ints with the following values: [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]. <code>5: 4</code> means 0 0 0 0 to index 5, then 4.</p>"},{"location":"Misc/learning-go/#slices","title":"Slices","text":"<p>One slice is appended onto another by using the <code>\u2026</code> operator to expand the source slice into individual values.</p> <pre><code>y := []int{20, 30, 40}\nx = append(x, y...)\n</code></pre> <p>When a slice grows via append, the Go runtime usually increases a slice by more than one each time it runs out of capacity. The rules as of Go 1.14 are to double the size of the slice when the capacity is less than 1,024 and then grow by at least 25% afterward.</p> <p>Declaring slices</p> <pre><code>var data []int // a slice that stays nil\nvar x = []int{} // empty slice zero-length, non-nil\ndata := []int{2, 4, 6, 8} // slice with default values\nx := make([]int, 0, 5)\n</code></pre> <p>If you have a good idea of how large your slice needs to be, use <code>make</code> with a zero length and a specified capacity.</p> <p>Append can make overlapping slices. The full slice expression includes a third part, which indicates the last position in the parent slice\u2019s capacity that\u2019s available for the subslice.</p> <pre><code>y := x[:2:2]\nz := x[2:4:4]\n</code></pre> <p>copy</p> <p>Create a slice that\u2019s independent of the original, use the built-in <code>copy</code> function.</p> <pre><code>x := []int{1, 2, 3, 4}\ny := make([]int, 4)\nnum := copy(y, x)\ncopy(y, x[2:]) // first is destination and second is source\n</code></pre> <p>Converting strings to slices</p> <pre><code>var s string = \"Hello\"\nvar bs []byte = []byte(s)\nvar rs []rune = []rune(s)\n\n[72 101 108 108 111 44 32 240 159 140 158]\n[72 101 108 108 111 44 32 127774]\n</code></pre>"},{"location":"Misc/learning-go/#map","title":"Map","text":"<p><code>map[keyType]valueType</code></p> <pre><code>var nilMap map[string]int // A nil map is equivalent to an empty map\n// except that elements can\u2019t be added.\ntotalWins := map[string]int{} // empty map\nm := map[string]int{\n    \"hello\": 5,\n    \"world\": 10,\n}\nages := make(map[int][]string, 10) // know length\n\ntotalWins[\"Orcas\"] = 1 // write\nfmt.Println(totalWins[\"Orcas\"]) // read\ndelete(m, \"hello\") // delete\n</code></pre> <p>The comma ok Idiom</p> <pre><code>m := map[string]int{\n  \"hello\": 5,\n  \"world\": 0,\n}\nv, ok := m[\"hello\"]\n</code></pre> <p>Using Maps as Sets</p> <pre><code>intSet := map[int]bool{}\nvals := []int{5, 10, 2, 5, 8, 7, 3, 9, 1, 2, 10}\nfor _, v := range vals {\n    intSet[v] = true\n}\nif intSet[100] {\n    fmt.Println(\"100 is in the set\")\n}\n</code></pre> <p>Comparing and Converting Structs</p> <p>Go does allow you to perform a type conversion from one struct type to another if the fields of both structs have the same names, order, and types.</p>"},{"location":"Misc/learning-go/#chapter-4-blocks-shadows-and-control-structures","title":"Chapter 4. Blocks, Shadows, and Control Structures","text":""},{"location":"Misc/learning-go/#for-four-ways","title":"for, Four Ways","text":"<pre><code>// A complete, C-style for\nfor i := 0; i &lt; 10; i++ {\n    fmt.Println(i)\n}\n// A condition-only for\ni := 1\nfor i &lt; 100 {\n    fmt.Println(i)\n    i = i * 2\n}\n// An infinite for\nfor {\n    fmt.Println(\"Hello\")\n}\n// for-range\nevenVals := []int{2, 4, 6, 8, 10, 12}\nfor _, v := range evenVals {\n    fmt.Println(v)\n}\n\nuniqueNames := map[string]bool{\"Fred\": true, \"Raul\": true, \"Wilma\": true}\nfor k := range uniqueNames {\n    fmt.Println(k)\n}\n</code></pre> <p>The most common reason for iterating over the key is when a map is being used as a set.</p>"},{"location":"Misc/learning-go/#chapter-5-functions","title":"Chapter 5. Functions","text":""},{"location":"Misc/learning-go/#declaring-and-calling-functions","title":"Declaring and Calling Functions","text":"<p>Variadic Input Parameters</p> <p>Variadic parameters allows any number of input parameters</p> <pre><code>func addTo(base int, vals ...int) []int {\n        out := make([]int, 0, len(vals))\n        for _, v := range vals {\n        out = append(out, base+v)\n    }\n        return out\n}\nfmt.Println(addTo(3))\nfmt.Println(addTo(3, 2))\nfmt.Println(addTo(3, 2, 4, 6, 8))\na := []int{4, 3}\nfmt.Println(addTo(3, a...))\nfmt.Println(addTo(3, []int{1, 2, 3, 4, 5}...))\n</code></pre> <p>Named Return Values</p> <p>While named return values can sometimes help clarify your code, they do have some potential corner cases - problem of shadowing</p> <pre><code>func divAndRemainder(numerator, denominator int) (result int, remainder int,\n    err error) {\n  // assign some values\n  result, remainder = 20, 30\n  if denominator == 0 {\n  return 0, 0, errors.New(\"cannot divide by zero\")\n  }\n  return numerator / denominator, numerator % denominator, nil\n}\n</code></pre> <p>Pass 5 and 2 to this function. Return 2 1.</p> <p>Blank Returns\u2014Never Use These!</p> <p>When there\u2019s invalid input, we return immediately. At first, you might find blank returns handy since they allow you to avoid some typing. However, most experienced Go developers consider blank returns a bad idea because they make it harder to understand data flow.</p>"},{"location":"Misc/learning-go/#functions-are-values","title":"Functions Are Values","text":"<pre><code>func add(i int, j int) int { return i + j }\nfunc sub(i int, j int) int { return i - j }\nvar opMap = map[string]func(int, int) int{\n  \"+\": add,\n  \"-\": sub,\n}\n</code></pre>"},{"location":"Misc/learning-go/#closures","title":"Closures","text":"<p>Functions declared inside of functions are closures.</p> <pre><code>func adder() func(int) int {\n    sum := 0\n    return func(x int) int {\n        sum += x\n        return sum\n    }\n}\n\nfunc main() {\n    pos, neg := adder(), adder()\n    for i := 0; i &lt; 10; i++ {\n        fmt.Println(\n            pos(i),\n            neg(-2*i),\n        )\n    }\n}\n</code></pre>"},{"location":"Misc/learning-go/#go-is-call-by-value","title":"Go Is Call By Value","text":"<p>It means that when you supply a variable for a parameter to a function, Go always makes a copy of the value of the variable</p> <pre><code>type person struct {\n  age int\n  name string\n}\n\nfunc modifyFails(i int, s string, p person) {\n  i = i * 2\n  s = \"Goodbye\"\n  p.name = \"Bob\"\n}\n\nfunc main() {\n  p := person{}\n  i := 2\n  s := \"Hello\"\n  modifyFails(i, s, p)\n  fmt.Println(i, s, p)\n  // won't change: 2 Hello {0 }\n}\n</code></pre> <p>Write a function to modify a map parameter and a function to modify a slice parameter. Any changes made to a map parameter are reflected in the variable passed into the function (includes delete). For a slice, you can modify any element in the slice, but you can\u2019t lengthen the slice. It\u2019s because maps and slices are both implemented with pointers.</p>"},{"location":"Misc/learning-go/#chapter-6-pointer","title":"Chapter 6. Pointer","text":""},{"location":"Misc/learning-go/#a-quick-pointer-primer","title":"A Quick Pointer Primer","text":"<p>A pointer type</p> <pre><code>x := 10\nvar pointerToX *int // *int is just a type like: var i int\npointerToX = &amp;x // store address of a variable\nfmt.Println(pointerToX) // prints a memory address\nfmt.Println(*pointerToX) // prints 10\nz := 5 + *pointerToX\nfmt.Println(z) // prints 15\n</code></pre> <p>While different types of variables can take up different numbers of memory locations (boolean 1 byte, int32 4 byte), every pointer, no matter what type it is pointing to, is always the same size: a number that holds the location in memory where the data is stored.</p> <pre><code>func failedUpdate(px *int) {\n  x2 := 20\n  px = &amp;x2\n}\nfunc update(px *int) {\n  *px = 20\n}\nfunc main() {\n  x := 10\n  failedUpdate(&amp;x)\n  fmt.Println(x) // prints 10\n  update(&amp;x)\n  fmt.Println(x) // prints 20\n}\n</code></pre> <p>we start with <code>x</code> in <code>main</code> set to <code>10</code>. When we call <code>failedUpdate</code>, we copy the address of <code>x</code> into the parameter <code>px</code>. Next, we declare <code>x2</code> in <code>failedUpdate</code>, set to <code>20</code>. We then point <code>px</code> in <code>failedUpdate</code> to the address of <code>x2</code>. When we return to main, the value of <code>x</code> is unchanged. When we call update, we copy the address of <code>x</code> into <code>px</code> again. However, this time we change the value of what <code>px</code> in update points to, the variable <code>x</code> in main. When we return to main, <code>x</code> has been changed.</p> <p>####Pointer Passing Performance</p> <p>The time to pass a pointer into a function is constant for all data sizes, roughly one nanosecond. This makes sense, as the size of a pointer is the same for all data types. It takes about a millisecond once the value gets to be around 10 megabytes of data.</p> <p>The behavior for returning a pointer versus returning a value is more interesting. For data structures that are smaller than a megabyte, it is actually slower to return a pointer type than a value type. For example, a 100-byte data structure takes around 10 nanoseconds to be returned, but a pointer to that data structure takes about 30 nano\u2010 seconds. Once your data structures are larger than a megabyte, the performance advantage flips. It takes nearly 2 milliseconds to return 10 megabytes of data, but a little more than half a millisecond to returnq a pointer to it.</p>"},{"location":"Misc/learning-go/#the-difference-between-maps-and-slices","title":"The Difference Between Maps and Slices","text":"<p>You should avoid using maps for input parameters or return values, especially on public APIs.</p> <p>Changing the values in the slice changes the memory that the pointer points to, so the changes are seen in both the copy and the original. Changes to the length and capacity are not reflected back in the original, because they are only in the copy. Changing the capacity means that the pointer is now pointing to a new, bigger block of memory.</p> <p>The reason you can pass a slice of any size to a function is that the data that\u2019s passed to the function is the same for any size slice: two int values and a pointer. The reason that you can\u2019t write a function that takes an array of any size is because the entire array is passed to the function, not just a pointer to the data.</p>"},{"location":"Misc/learning-go/#chapter-7-types-methods-and-interfaces","title":"Chapter 7. Types, Methods, and Interfaces","text":"<p>Go allows you to declare a type at any block level, from the package block down.</p> <pre><code>type Score int\ntype Converter func(string)Score\ntype TeamScores map[string]Score\n</code></pre>"},{"location":"Misc/learning-go/#methods","title":"Methods","text":"<pre><code>type Person struct {\n  FirstName string\n  LastName string\n  Age int\n}\nfunc (p Person) String() string {\n  return fmt.Sprintf(\"%s %s, age %d\", p.FirstName, p.LastName, p.Age)\n}\n</code></pre> <p>Method declarations look just like function declarations, with one addition: the receiver specification. The receiver appears between the keyword func and the name of the method. The receiver name <code>p</code> appears before the type <code>Person</code>.</p> <p>Pointer Receivers and Value Receivers</p> <ul> <li>If your method modifies the receiver or needs to handle nil instances, you must use a pointer receiver.</li> <li>If your method doesn\u2019t modify the receiver, you can use a value receiver</li> </ul> <pre><code>type Counter struct {\n  total int\n  lastUpdated time.Time\n}\nfunc (c *Counter) Increment() {\n  c.total++\n  c.lastUpdated = time.Now()\n}\nfunc (c Counter) String() string {\n  return fmt.Sprintf(\"total: %d, last updated: %v\", c.total, c.lastUpdated)\n}\n</code></pre> <p>The rules for passing values to functions still apply. If you pass a value type to a function and call a pointer receiver method on the passed value, you are invoking the method on a copy.</p> <pre><code>func doUpdateWrong(c Counter) {\n  c.Increment()\n  fmt.Println(\"in doUpdateWrong:\", c.String())\n}\nfunc doUpdateRight(c *Counter) {\n  c.Increment()\n  fmt.Println(\"in doUpdateRight:\", c.String())\n}\nfunc main() {\n  var c Counter\n  doUpdateWrong(c)\n  fmt.Println(\"in main:\", c.String())\n  doUpdateRight(&amp;c)\n  fmt.Println(\"in main:\", c.String())\n}\n</code></pre> <p>Methods Are Functions Too</p> <pre><code>type Adder struct {\n  start int\n}\nfunc (a Adder) AddTo(val int) int {\n  return a.start + val\n}\n</code></pre> <ul> <li>We create an instance of the type in the usual way and invoke its method:</li> </ul> <pre><code>myAdder := Adder{start: 10}\nfmt.Println(myAdder.AddTo(5)) // prints 15\n</code></pre> <ul> <li>We can also assign the method to a variable or pass it to a parameter of type <code>func(int)int</code>. This is called a method value:</li> </ul> <pre><code>f1 := myAdder.AddTo\nfmt.Println(f1(10))\n</code></pre> <ul> <li>You can also create a function from the type itself. This is called a method expression:</li> </ul> <pre><code>f2 := Adder.AddTo\nfmt.Println(f2(myAdder, 15)) // prints 25\n</code></pre> <p>In the case of a method expression, the first parameter is the receiver for the method; our function signature is func(Adder, int) int.</p> <p>iota</p> <p>his means that it assigns 0 to the first constant , 1 to the second constant , and so on. When a new const block is created, iota is set back to 0.</p> <pre><code>type BitField int\nconst (\n  Field1 BitField = 1 &lt;&lt; iota // assigned 1\n  Field2 // assigned 2\n  Field3 // assigned 4\n  Field4 // assigned 8\n)\n</code></pre>"},{"location":"Misc/learning-go/#use-embedding-for-composition","title":"Use Embedding for Composition","text":"<pre><code>type Employee struct {\n  Name string\n  ID string\n}\nfunc (e Employee) Description() string {\n  return fmt.Sprintf(\"%s (%s)\", e.Name, e.ID)\n}\ntype Manager struct {\n  Employee\n  Reports []Employee\n  }\nfunc (m Manager) FindNewEmployees() []Employee {\n// do business logic\n}\n\nm := Manager{\n  Employee: Employee{\n  Name: \"Bob Bobson\",\n  ID: \"12345\",\n  },\n  Reports: []Employee{},\n}\n  fmt.Println(m.ID) // prints 12345\n  fmt.Println(m.Description()) // prints Bob Bobson (12345)\n</code></pre>"},{"location":"Misc/learning-go/#embedding-is-not-inheritance","title":"Embedding Is Not Inheritance","text":"<pre><code>var eFail Employee = m // compilation error!\nvar eOK Employee = m.Employee // ok!\n</code></pre> <p>While embedding one concrete type inside another won\u2019t allow you to treat the outer type as the inner type, the methods on an embedded field do count toward the method set of the containing struct. This means they can make the containing struct implement an interface</p> <pre><code>type Inner struct {\n  A int\n}\nfunc (i Inner) IntPrinter(val int) string {\n  return fmt.Sprintf(\"Inner: %d\", val)\n}\nfunc (i Inner) Double() string {\n  return i.IntPrinter(i.A * 2)\n}\ntype Outer struct {\n  Inner\n  S string\n}\nfunc (o Outer) IntPrinter(val int) string {\n  return fmt.Sprintf(\"Outer: %d\", val)\n}\nfunc main() {\n    o := Outer{\n    Inner: Inner{\n    A: 10,\n    },\n    S: \"Hello\",\n  }\n  fmt.Println(o.Double())\n}\nRunning this code produces the output:\nInner: 20\n</code></pre>"},{"location":"Misc/learning-go/#interface","title":"Interface","text":"<p>Interfaces specify what callers need. The client code defines the interface to specify what functionality it requires.</p> <pre><code>type LogicProvider struct {}\nfunc (lp LogicProvider) Process(data string) string {\n  // business logic\n}\ntype Logic interface {\n  Process(data string) string\n}\ntype Client struct{\n  L Logic\n}\nfunc(c Client) Program() {\n  // get data from somewhere\n  c.L.Process(data)\n}\nmain() {\n  c := Client{\n  L: LogicProvider{},\n  }\n  c.Program()\n}\n</code></pre> <p>Interfaces are named collections of method signatures.</p> <p>You have a square and a circle, and want to get the area for each.</p> <pre><code>type rect struct {\n    width, height float64\n}\ntype circle struct {\n    radius float64\n}\n</code></pre> <pre><code>// Now you need functions to display the area and perim. You might write code like this.\nfunc (r rect) area() float64 {\n  return r.width * r.height\n}\nfunc (r rect) perim() float64 {\n  return 2*r.width + 2*r.height\n}\n\nfunc (c circle) area() float64 {\n  return math.Pi * c.radius * c.radius\n}\nfunc (c circle) perim() float64 {\n  return 2 * math.Pi * c.radius\n}\n</code></pre> <p>Both functions do exactly the same thing. Because Go is strongly typed we need to have two functions. One to display the area of rect, and one to display the area of circles. We can write a single function that takes both.</p> <pre><code>type geometry interface {\n  area() float64\n  perim() float64\n}\n</code></pre> <p>Now we can throw away our two functions and write a single function that takes an instance of <code>geometry</code>.</p> <pre><code>func measure(g geometry) {\n    fmt.Println(g)\n    fmt.Println(g.area())\n    fmt.Println(g.perim())\n}\n\nfunc main() {\n    r := rect{width: 3, height: 4}\n    c := circle{radius: 5}\n    measure(r) // {3 4} 12 14\n    measure(c) // 5 78.53981633974483 31.41592653589793\n}\n</code></pre>"},{"location":"Misc/learning-go/#accept-interfaces-return-structs","title":"Accept Interfaces, Return Structs","text":"<p>You\u2019ll often hear experienced Go developers say that your code should \u201cAccept inter\u2010 faces, return structs.\u201d What this means is that the business logic invoked by your functions should be invoked via interfaces, but the output of your functions should be a concrete type.</p>"},{"location":"Misc/learning-go/#the-empty-interface-says-nothing","title":"The Empty Interface Says Nothing","text":"<p>Sometimes in a statically typed language, you need a way to say that a variable could store a value of any type. Go uses interface{} to represent this:</p> <pre><code>  var i interface{}\n  i = 20\n  i = \"hello\"\n  i = struct {\n  FirstName string\n  LastName string\n  } {\"Fred\", \"Fredson\"}\n</code></pre> <p>You should note that interface{} isn\u2019t special case syntax. An empty interface type simply states that the variable can store any value whose type implements zero or more methods. This just happens to match every type in Go. Because an empty inter\u2010 face doesn\u2019t tell you anything about the value it represents, there isn\u2019t a lot you can do with it. One common use of the empty interface is as a placeholder for data of uncer\u2010 tain schema that\u2019s read from an external source, like a JSON file:</p> <pre><code>  // one set of braces for the interface{} type,\n  // the other to instantiate an instance of the map\n  data := map[string]interface{}{}\n  contents, err := ioutil.ReadFile(\"testdata/sample.json\")\n  if err != nil {\n  return err\n  }\n  defer contents.Close()\n  json.Unmarshal(contents, &amp;data)\n// the contents are now in the data map\n</code></pre> <p>Another use of interface{} is as a way to store a value in a user-created data structure.</p> <pre><code>type LinkedList struct {\n  Value interface{}\n  Next *LinkedList\n}\nfunc (ll *LinkedList) Insert(pos int, val interface{}) *LinkedList {\n    if ll == nil || pos == 0 {\n    return &amp;LinkedList{\n      Value: val,\n      Next: ll,\n    }\n  }\n  ll.Next = ll.Next.Insert(pos-1, val)\n  return ll\n}\n</code></pre>"},{"location":"Misc/learning-go/#type-switches","title":"Type Switches","text":"<pre><code>func doThings(i interface{}) {\n switch j := i.(type) {\n case nil:\n // i is nil, type of j is interface{}\n case int:\n // j is of type int\n case MyInt:\n // j is of type MyInt\n case io.Reader:\n // j is of type io.Reader\n case string:\n // j is a string\n case bool, rune:\n // i is either a bool or rune, so j is of type interface{}\n default:\n // no idea what i is, so j is of type interface{}\n }\n}\n</code></pre>"},{"location":"Misc/learning-go/#chapter-8-errors","title":"Chapter 8. Errors","text":"<p>When a function executes as expected, <code>nil</code> is returned for the error parameter. If something goes wrong, an error value is returned instead.</p> <pre><code>func calcRemainderAndMod(numerator, denominator int) (int, int, error) {\n if denominator == 0 {\n   return 0, 0, errors.New(\"denominator is 0\")\n }\n return numerator / denominator, numerator % denominator, nil\n}\n</code></pre> <p>Unlike languages with exceptions, Go doesn\u2019t have special constructs to detect if an error was returned. Whenever a function returns, use an if statement to check the error variable to see if it is non-nil:</p> <pre><code>func main() {\n numerator := 20\n denominator := 3\n remainder, mod, err := calcRemainderAndMod(numerator, denominator)\n if err != nil {\n   fmt.Println(err)\n   os.Exit(1)\n }\n fmt.Println(remainder, mod)\n}\n// error is a built-in interface that defines a single method:\ntype error interface {\n Error() string\n}\n</code></pre>"},{"location":"Misc/learning-go/#use-strings-for-simple-errors","title":"Use Strings for Simple Errors","text":"<p>Go\u2019s standard library provides two ways to create an error from a string. <code>errors.New()</code> and <code>fmt.Errorf()</code></p> <pre><code>func doubleEven(i int) (int, error) {\n if i % 2 != 0 {\n   return 0, errors.New(\"only even numbers are processed\")\n }\n return i * 2, nil\n}\n\nfunc doubleEven(i int) (int, error) {\nif i % 2 != 0 {\n  return 0, fmt.Errorf(\"%d isn't an even number\", i)\n}\nreturn i * 2, nil\n}\n</code></pre>"},{"location":"Misc/learning-go/#chapter-9-modules-packages-and-imports","title":"Chapter 9. Modules, Packages, and Imports","text":"<p>A module is the root of a Go library or application, stored in a repository. Modules consist of one or more pack\u2010 ages, which give the module organization and structure.</p> <p>Package names should be descriptive. Rather than have a package called <code>util</code>, create a package name that describes the functionality provided by the package. For example, say you have two helper functions: one to extract all names from a string and another to format names properly. Don\u2019t create two functions in a <code>util</code> package called <code>ExtractNames</code> and <code>FormatNames</code>. If you do, every time you use these functions, they will be referred to as <code>util.ExtractNames</code> and <code>util.FormatNames</code>, and that util package tells you nothing about what the func\u2010 tions do.</p> <p>It\u2019s better to create one function called <code>Names</code> in a package called <code>extract</code> and a second function called <code>Names</code> in a package called <code>format</code>. It\u2019s OK for these two functions to have the same name, because they will always be disambiguated by their package names. The first will be referred to as <code>extract.Names</code> when imported, and the second will be referred to as <code>format.Names</code>.</p>"},{"location":"Misc/learning-go/#will-be-continued-in-the-future","title":"Will be continued in the future ...","text":""},{"location":"Misc/learning-go/#references","title":"References","text":"<ul> <li>Learning Go: An Idiomatic Approach to Real-World Go Programming</li> </ul>"}]}